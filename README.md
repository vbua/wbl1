# WB Tech: level # 1 (Golang)
## Устные вопросы
1. **Какой самый эффективный способ конкатенации строк?**
    ```
    var sb strings.Builder
    sb.WriteString("a")
    fmt.Println(sb.String())
    ```
2. **Что такое интерфейсы, как они применяются в Go?**

   Интерфейсы описывают поведение типов. В интерфейсе указываются наборы сигнатур методов. Если у типа есть все методы
   интерфейса, то это означает, что этот тип реализует (удовлетворяет) интерфейс.

   Интерфейсы чаще всего используются как аргументы функций. В таком случае в функцию можно подставить любой тип, который
   реализует указанный интерфейс.

   Также иногда используется пустой интерфейс. Его реализуют все типы. Но злоупотреблять пустыми интерфейсами не стоит,
   так как теряется смысл в типизации языка.

   Внутри интерфейса в поле tab хранится динамический тип, который был преобразован в интерфейс. А также в поле
   data хранится указатель на значение объекта. Если оба эти поля nil, то только в этом случае интерфейс равен nil.

   Интерфейс поддерживает синтаксис утверждения типа. Он нужен для того, чтобы интерфейс преобразовать к типу в поел tab.
   Но если мы не угадали с типом, то будет паника. В случае, когда тип не известен, то можно применить конструкцию
   type switch, которая позволяет методом перебора определить динамический тип интерфейса.
3. **Чем отличаются RWMutex от Mutex?**

   RWMutex позволяет делать конкурентные чтения пока нет записей. Перед записью в защищаемый мьютексом объект
   делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, пока вы не отпустите
   мьютекс через .Unlock(). Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других
   горутинах блокируются, вызовы .RLock() спокойно проходят.
4. **Чем отличаются буферизированные и не буферизированные каналы?**

   Не буферизированный канал блокируется сразу же как только в него что-то положили пока с него не прочитают.
   А в буферизированном канале есть буфер/ёмкость (cap), то есть туда можно положить заданное количество данных до блокировки.
   Буфер. канал блокируется только при записи данных capacity+1. Также надо учесть, что буфер. канал жадный, то есть он
   не разблокируется пока с него все не прочитают.
5. **Какой размер у структуры struct{}{}?**

   Ноль.
6. **Есть ли в Go перегрузка методов или операторов?**

   Нет.
7. **В какой последовательности будут выведены элементы map[int]int?**
   ```
   Пример:
   m[0]=1
   m[1]=124
   m[2]=281
   ```
   По порядку, если просто вывести всю мапу разом. При итерации в случайном порядке.
8. **В чем разница make и new?**

   new выделяет память, заполняет ее дефолтным значением типа и возвращает указатель.

   make служит для создания slice, map, chan. Эти типы требуют инициализацию для работы с ними, поэтому new не подходит,
   так как дефолтное значение этих типов nil.
9. **Сколько существует способов задать переменную типа slice или map?**<br>
   ```
   // slice 5
   s1 := make([]int, 1, 2)
   var s2 []int = []int{1, 2, 3}
   var s3 = []int{1, 2, 3}
   s4 := new([]int) // получаем указатель на nil слайс, но работать с ним можно через append
   var s5 []int // получаем nil слайс, но работать с ним можно через append
   
   // map 5
   m1 := make(map[int]int, 1)
   var m2 map[int]int = map[int]int{1: 2, 2: 4, 3: 5}
   var m3 = map[int]int{1: 2, 2: 4, 3: 5} 
   m4 := map[int]int{1: 2, 2: 4, 3: 5} 
   m5 := new([]int) // через new мапу лучше не создавать, так как с nil мапой нельзя работать
   var m6 map[int]int // так тоже лучше не делать, так как опять же получаем nil мапу
   ```
10. **Что выведет данная программа и почему?**
    ```
    func update(p *int) {
    	b := 2
    	p = &b
    }
    
    func main() {
    	var (
    		a = 1
    		p = &a
    	)
    	fmt.Println(*p)
    	update(p)
    	fmt.Println(*p)
    }
    ```
    Выведет:
    ```
    1
    1
    ```
    В первом случае мы разыменовываем переменную, тем самым получая значение по адресу.
    Во втором случае мы переписываем значение локальной переменной p, при этом p вне функции остается неизменной,
    так как в функции update копия переменной p.
11. **Что выведет данная программа и почему?**
    ```
    func main() {
     wg := sync.WaitGroup{}
     for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
           fmt.Println(i)
           wg.Done()
        }(wg, i)
     }
     wg.Wait()
     fmt.Println("exit")
    }
    ```
    Дедлок, так как в горутину передается вейтгруп по значению. Он не связан с внешней вейтгруп.
    Нужно передать указатель на вейтгруп.
12. **Что выведет данная программа и почему?**
    ```
    func main() {
     n := 0
     if true {
        n := 1
        n++
     }
     fmt.Println(n)
    }
    ```
    Выведет 0. В if новая область видимости и там мы создаем новую переменную n.
13. **Что выведет данная программа и почему?**
    ```
    func someAction(v []int8, b int8) {
     v[0] = 100
     v = append(v, b)
    }
    
    func main() {
     var a = []int8{1, 2, 3, 4, 5}
     someAction(a, 6)
     fmt.Println(a)
    }
    ```
    Выведете 100, 2, 3, 4, 5. Когда мы передали слайс в функцию, то создалась его копия,
    но внутри слайса лежит указатель на тот же массив, что и у переданного слайса, поэтому когда мы меняем нулевой элемент,
    то он меняется и у низлежащего массива, на который указывают оба слайса. А вот когда мы делаем append,
    у слайса не хватает ёмкости для добавления еще одного элемента, поэтому создается указатель на новый массив
    и слайс больше не меняет предыдущий массив.
14. **Что выведет данная программа и почему?**
    ```
    func main() {
     slice := []string{"a", "a"}
    
     func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
     }(slice)
     fmt.Print(slice)
    }
    ```
    Выведется [b b a][a a]. После append создается новый слайс с указателем на новый массив, так как ёмкости не хватает,
    поэтому внутри функции мы меняем новый массив. А слайс, который вне функции, все еще указывает на старый массив.