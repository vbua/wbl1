# WB Tech: level # 1 (Golang)
## Устные вопросы
1. **Какой самый эффективный способ конкатенации строк?**<br>
    ```
    var sb strings.Builder
    sb.WriteString("a")
    fmt.Println(sb.String())
    ```
2. **Что такое интерфейсы, как они применяются в Go?**<br>
Интерфейсы описывают поведение типов. В интерфейсе указываются наборы сигнатур методов. Если у типа есть все методы 
интерфейса, то это означает, что этот тип реализует (удовлетворяет) интерфейс.
<br><br>
Интерфейсы чаще всего используются как параметры функций. В таком случае в функцию можно подставить любой тип, который 
реализует указанный интерфейс.<br><br>
Также иногда используется пустой интерфейс. Его реализуют все типы. Но злоупотреблять пустыми интерфейсами не стоит, 
так как теряется смысл в типизации языка.
3. **Чем отличаются RWMutex от Mutex?**<br>
RWMutex позволяет делать конкурентные чтения пока нет записей. Перед записью в защищаемый мьютексом объект 
делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, пока вы не отпустите 
мьютекс через .Unlock(). Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других 
горутинах блокируются, вызовы .RLock() спокойно проходят. 
4. **Чем отличаются буферизированные и не буферизированные каналы?**<br>
Не буферизированный канал блокируется сразу же как только в него что-то положили пока с него не прочитают.
А в буферизированном канале есть буфер/ёмкость (cap), то есть туда можно положить заданное количество данных до блокировки. 
Буфер. канал блокируется только при записи данных capacity+1. Также надо учесть, что буфер. канал жадный, то есть он
не разблокируется пока с него все не прочитают.
5. **Какой размер у структуры struct{}{}?**
Ноль.
6. **Есть ли в Go перегрузка методов или операторов?**<br>
Нет.
7. **В какой последовательности будут выведены элементы map[int]int?**<br>
   ```
   Пример:
   m[0]=1
   m[1]=124
   m[2]=281
   ```
   По порядку, если просто вывести всю мапу разом. При итерации в случайном порядке.
8. **В чем разница make и new?**<br>
make возвращает значение, а new возвращает указатель. make выделяет память и инициализирует только объекты типа: 
slice, map, chan.
9. **Сколько существует способов задать переменную типа slice или map?**<br>
   ```
   // 1
   a1 := make([]int, 1, 2)
   b1 := make(map[string]int, 1)
   
   // 2
   a2 := []int{1, 2, 3}
   b2 := map[string]int{"test": 2}
   
   // 3
   someArray := [6]{1, 2, 3, 4, 5, 6}
   a3 := someArray[2, 4]
   
   // 4 new возвращает указатель, поэтому надо разыменовать сразу
   a4 := *new([]int)
   b4 := *new([string]int)
   ```
10. **Что выведет данная программа и почему?**<br>
   ```
   func update(p *int) {
     b := 2
     p = &b
   }
   
   func main() {
     var (
        a = 1
        p = &a
     )
     fmt.Println(*p)
     update(p)
     fmt.Println(*p)
   }
   ```
   Выведет:<br>
   1<br>
   1<br>
   В первом случае мы разыменовываем переменную, тем самым получая значение по адресу. 
   Во втором случае мы переписываем значение локальной переменной p, при этом p вне функции остается неизменной,
   так как в функции update копия переменной p.
11. **Что выведет данная программа и почему?**<br>
   ```
   func main() {
     wg := sync.WaitGroup{}
     for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
           fmt.Println(i)
           wg.Done()
        }(wg, i)
     }
     wg.Wait()
     fmt.Println("exit")
   }
   ```
   Дедлок, так как в горутину передается вейтгруп по значению. Он не связан с внешней вейтгруп. 
   Нужно передать указатель на вейтгруп.
12. **Что выведет данная программа и почему?**<br>
   ```
   func main() {
     n := 0
     if true {
        n := 1
        n++
     }
     fmt.Println(n)
   }
   ```
   Выведет 0. В if новая область видимости и там мы создаем новую переменную n.
13. **Что выведет данная программа и почему?**<br>
   ```
   func someAction(v []int8, b int8) {
     v[0] = 100
     v = append(v, b)
   }
   
   func main() {
     var a = []int8{1, 2, 3, 4, 5}
     someAction(a, 6)
     fmt.Println(a)
   }
   ```
   Выведете 100, 2, 3, 4, 5. Когда мы передали слайс в функцию, то создалась его копия, 
   но внутри слайса лежит указатель на тот же массив, что и у переданного слайса, поэтому когда мы меняем нулевой элемент,
   то он меняется и у низлежащего массива, на который указывают оба слайса. А вот когда мы делаем append, 
   у слайса не хватает ёмкости для добавления еще одного элемента, поэтому создается указатель на новый массив 
   и слайс больше не меняет предыдущий массив.
14. **Что выведет данная программа и почему?**<br>
   ```
   func main() {
     slice := []string{"a", "a"}
   
     func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
     }(slice)
     fmt.Print(slice)
   }
   ```
   Выведется [b b a][a a]. После append создается новый слайс с указателем на новый массив, так как ёмкости не хватает,
   поэтому внутри функции мы меняем новый массив. А слайс, который вне функции, все еще указывает на старый массив.